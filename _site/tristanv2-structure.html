<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="This section describes how the domain decomposition works, and how the field quantities and particles are stored in memory.">
<meta name="keywords" content=" pic, general, structure, memory, domain, field, particle, mpi, meshblock">
<title>Structure of Memory | Tristan v2 Wiki</title>
<link rel="stylesheet" href="css/syntax.css">

<link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<!--<link rel="stylesheet" type="text/css" href="css/bootstrap.min.css">-->
<link rel="stylesheet" href="css/modern-business.css">
<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<link rel="stylesheet" href="css/customstyles.css">
<link rel="stylesheet" href="css/custom.css">
<link rel="stylesheet" href="css/boxshadowproperties.css">
<!-- most color styles are extracted out to here -->
<link rel="stylesheet" href="css/theme-blue.css">

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="js/jquery.navgoco.min.js"></script>


<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<!-- Anchor.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.0/anchor.min.js"></script>
<script src="js/toc.js"></script>
<script src="js/customscripts.js"></script>

<link rel="shortcut icon" href="images/favicon.ico">

<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link rel="alternate" type="application/rss+xml" title="tristan-v2" href="http://localhost:4000/feed.xml">

    <script>
        // $(document).ready(function() {
        //     // Initialize navgoco with default options
        //     $("#mysidebar").navgoco({
        //         caretHtml: '',
        //         accordion: false,
        //         openClass: 'active', // open
        //         save: false, // leave false or nav highlighting doesn't work right
        //         cookie: {
        //             name: 'navgoco',
        //             expires: false,
        //             path: '/'
        //         },
        //         slide: {
        //             duration: 400,
        //             easing: 'swing'
        //         }
        //     });
        //
        //     $("#collapseAll").click(function(e) {
        //         e.preventDefault();
        //         $("#mysidebar").navgoco('toggle', false);
        //     });
        //
        //     $("#expandAll").click(function(e) {
        //         e.preventDefault();
        //         $("#mysidebar").navgoco('toggle', true);
        //     });
        //
        // });

    </script>
    <script>
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        })
    </script>
    <script>
        $(document).ready(function() {
            $("#tg-sb-link").click(function() {
                $("#tg-sb-sidebar").toggle();
                $("#tg-sb-content").toggleClass('col-md-9');
                $("#tg-sb-content").toggleClass('col-md-12');
                $("#tg-sb-icon").toggleClass('fa-toggle-on');
                $("#tg-sb-icon").toggleClass('fa-toggle-off');
            });
        });
    </script>
    
    <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [             // start/end delimiter pairs for display math
      ['$$', '$$'],
      ['\\[', '\\]']
    ]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>
<body>
<!-- Navigation -->
<nav class="navbar navbar-inverse navbar-static-top">
    <div class="container topnavlinks">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="fa fa-home fa-lg navbar-brand" href="index.html">&nbsp;<span class="projectTitle"> Tristan v2 Documentation</span></a>
        </div>
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <!-- toggle sidebar button -->
                <li><a id="tg-sb-link" href="#"><i id="tg-sb-icon" class="fa fa-toggle-on"></i> Nav</a></li>
                <!-- entries without drop-downs appear here -->




                
                
                
                <li><a href="https://github.com/PrincetonUniversity/tristan-v2" target="_blank" rel="noopener">Tristan v2 GitHub</a></li>
                
                
                
                <!-- entries with drop-downs appear here -->
                <!-- conditional logic to control which topnav appears for the audience defined in the configuration file.-->
                
                <!-- 
			<li>



  <a class="email" title="Submit feedback" href="#" onclick="javascript:window.location='mailto:?subject= feedback&body=I have some feedback about the Structure of Memory page: ' + window.location.href;"><i class="fa fa-envelope-o"></i> Feedback</a>

</li>

		 -->
                <!--comment out this block if you want to hide search-->
                <li>
                    <!--start search-->
                    <div id="search-demo-container">
                        <input type="text" id="search-input" placeholder="search...">
                        <ul id="results-container"></ul>
                    </div>
                    <script src="js/jekyll-search.js" type="text/javascript"></script>
                    <script type="text/javascript">
                            SimpleJekyllSearch.init({
                                searchInput: document.getElementById('search-input'),
                                resultsContainer: document.getElementById('results-container'),
                                dataSource: 'search.json',
                                searchResultTemplate: '<li><a href="{url}" title="Structure of Memory">{title}</a></li>',
                    noResultsText: 'No results found.',
                            limit: 10,
                            fuzzy: true,
                    })
                    </script>
                    <!--end search-->
                </li>
            </ul>
        </div>
        </div>
        <!-- /.container -->
</nav>

<!-- Page Content -->
<div class="container">
  <div id="main">
    <!-- Content Row -->
    <div class="row">
        
        
            <!-- Sidebar Column -->
            <div class="col-md-3" id="tg-sb-sidebar">
                

<ul id="mysidebar" class="nav">
  <li class="sidebarTitle">Tristan v2</li>
  
  
  
  <li>
      <a title="Home" href="#">Home</a>
      <ul>
          
          
          
          <li><a title="Latest updates" href="index.html">Latest updates</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="Getting Started" href="#">Getting Started</a>
      <ul>
          
          
          
          <li><a title="Configuring, compiling, running" href="tristanv2-configure.html">Configuring, compiling, running</a></li>
          
          
          
          
          
          
          <li><a title="Input file" href="tristanv2-inputfile.html">Input file</a></li>
          
          
          
          
          
          
          <li><a title="User file" href="tristanv2-userfile.html">User file</a></li>
          
          
          
          
          
          
          <li><a title="Visualization" href="tristanv2-visualization.html">Visualization</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="Code Description" href="#">Code Description</a>
      <ul>
          
          
          
          <li><a title="Particle-in-cell concept" href="tristanv2-pic-concept.html">Particle-in-cell concept</a></li>
          
          
          
          
          
          
          <li><a title="Simulation units" href="tristanv2-sim-units.html">Simulation units</a></li>
          
          
          
          
          
          
          <li class="active"><a title="Structure of memory" href="tristanv2-structure.html">Structure of memory</a></li>
          
          
          
          
          
          
          <li><a title="Numerical algorithms" href="tristanv2-algorithms.html">Numerical algorithms</a></li>
          
          
          
          
          
          
          <li><a title="Load balancing" href="tristanv2-loadbal.html">Load balancing</a></li>
          
          
          
          
          
          
          <li><a title="Radiation" href="tristanv2-radiation.html">Radiation</a></li>
          
          
          
          
          
          
          <li><a title="QED" href="tristanv2-qed.html">QED</a></li>
          
          
          
          
      </ul>
   </li>
     
      
  
  <li>
      <a title="Useful Guides" href="#">Useful Guides</a>
      <ul>
          
          
          
          <li><a title="Writing a user file" href="tristanv2-writinguserfile.html">Writing a user file</a></li>
          
          
          
          
          
          
          <li><a title="Supported flags" href="tristanv2-confflags.html">Supported flags</a></li>
          
          
          
          
          
          
          <li><a title="Writing a documentation" href="tristanv2-writingdoc.html">Writing a documentation</a></li>
          
          
          
          
          
          
          <li><a title="Coding style" href="tristanv2-codestyle.html">Coding style</a></li>
          
          
          
          
      </ul>
   </li>
     
      
      
      <!-- if you aren't using the accordion, uncomment this block: -->
     <!-- <p class="external">
         <a href="#" id="collapseAll">Collapse All</a> | <a href="#" id="expandAll">Expand All</a>
     </p> -->

</ul>

<!-- this highlights the active parent class in the navgoco sidebar. this is critical so that the parent expands when you're viewing a page. This must appear below the sidebar code above. Otherwise, if placed inside customscripts.js, the script runs before the sidebar code runs and the class never gets inserted.-->
<script>$("li.active").parents('li').toggleClass("active");</script>

            </div>
            
        

        <!-- Content Column -->
        <div class="col-md-9" id="tg-sb-content">
            <div class="post-header">
   <h1 class="post-title-main">Structure of Memory</h1>
</div>



<div class="post-content">

   
    <div class="summary">This section describes how the domain decomposition works, and how the field quantities and particles are stored in memory.</div>
   

    
    
<!-- this handles the automatic toc. use ## for subheads to auto-generate the on-page minitoc. if you use html tags, you must supply an ID for the heading element in order for it to appear in the minitoc. -->
<script>
$( document ).ready(function() {
  // Handler for .ready() called.

$('#toc').toc({ minimumHeaders: 0, listType: 'ul', showSpeed: 0, headers: 'h2,h3,h4' });

/* this offset helps account for the space taken up by the floating toolbar. */
$('#toc').on('click', 'a', function() {
  var target = $(this.getAttribute('href'))
    , scroll_target = target.offset().top

  $(window).scrollTop(scroll_target - 10);
  return false
})
  
});
</script>

<div id="toc"></div>

    


    

   <h2 id="memory-structure">Memory structure</h2>

<p>There are three main objects which are stored in memory locally on every core.</p>

<h5 id="1-simulation-domain-and-its-decomposition">1. Simulation domain and its decomposition.</h5>
<p>Each core has the information about the whole simulation domain and its decomposition, meaning that every MPI unit (core) knows which part of the domain is assigned to all the other MPI units. All the relevant information is stored locally in the <code class="language-plaintext highlighter-rouge">meshblocks(:)</code> array, which has a size of <code class="language-plaintext highlighter-rouge">mpi_size</code> (number of MPI processes launched).</p>

<h5 id="2-fields-in-the-cells-of-the-local-subdomain">2. Fields in the cells of the local subdomain.</h5>
<p>Field quantities, such as the components of the electric and magnetic field, as well as the components of the current density are stored locally on each MPI unit. These are simple 3d arrays for the cells corresponding to specific subdomain assigned to the specific MPI rank. These field arrays are, however, slightly larger than the size of the local subdomain (by <code class="language-plaintext highlighter-rouge">NGHOST</code> cells in each dimension) which allows to store a small part of data from the neighboring subdomains. This vastly increases the performance by decreasing the number of MPI communications required.</p>

<h5 id="3-particles">3. Particles.</h5>
<p>Since <code class="language-plaintext highlighter-rouge">Tristan v2</code> is has a multi-species architecture, particles are stored in the array called <code class="language-plaintext highlighter-rouge">species(:)</code>. Each <code class="language-plaintext highlighter-rouge">species(s)</code> object has a three dimensional array of tiles, <code class="language-plaintext highlighter-rouge">prtl_tile(:,:,:)</code>, which basically subdivides the local subdomain into finer regions (typically few cells in size). These tiles further contain all the necessary particle information, such as coordinates and velocities.</p>

<p>Visually the structure looks like the animation below. Further in this section we will discuss all the components in more details.</p>

<figure><img class="docimage" src="images/tristan_v2/structure/mem_struct.gif" alt="mem_struct" /></figure>

<h2 id="domains">Domains</h2>

<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> Relevant file: <code class="language-plaintext highlighter-rouge">src/objects/domain.F90</code>.</div>

<h3 id="mpi-parallelism">MPI Parallelism</h3>

<p>The key concept here is the meshblock or MPI domain (unit). Every core on the cluster is responsible for the computation on a certain chunk of the global domain. Let’s say we have a global simulation domain consisting of <code class="language-plaintext highlighter-rouge">mx * my * mz</code> cells in all 3 directions, and let’s assume we have <code class="language-plaintext highlighter-rouge">N = nx * ny * nz</code> cores. Given that <code class="language-plaintext highlighter-rouge">mx</code>, <code class="language-plaintext highlighter-rouge">my</code> and <code class="language-plaintext highlighter-rouge">mz</code> are divisible by <code class="language-plaintext highlighter-rouge">nx</code>, <code class="language-plaintext highlighter-rouge">ny</code> and <code class="language-plaintext highlighter-rouge">nz</code>, we can distribute our global simulation domain evenly between all <code class="language-plaintext highlighter-rouge">N</code> cores, each core doing computation on a particular grid of the size <code class="language-plaintext highlighter-rouge">(mx/nx) * (my/ny) * (mz/nz)</code>.</p>

<p>The illustration of this is shown in the image below, red numbers on each meshblock is the corresponding MPI rank, rank of the core which operates on a given domain. Notice how the ranking goes from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">nx - 1</code> along x-axis, etc, the last rank will be the <code class="language-plaintext highlighter-rouge">nx * ny * nz - 1</code>.</p>

<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> In certain situations we might want to split the domain unevenly, to make sure all the cores have the same workload during the simulation. For that in the future we will use the concept called the load balancing. Right now, however, all the following logic is agnostic to whether the domain is divided evenly or not.</div>

<p>During our simulation we will need to interchange information between the MPI processes (e.g., send field quantities back and forth, send particles, etc), and for that we will need to know exactly what the neighborhood of our current MPI meshblock is (i.e., what MPI rank operates there etc).</p>

<figure><img class="docimage" src="images/tristan_v2/structure/domain1.png" alt="domain3d" /></figure>

<h3 id="meshblocks-mpi-domains">Meshblocks (MPI Domains)</h3>

<p>All MPI processes perform the same code on a chunk of the global domain corresponding to their rank. In order to keep these processes synced, we keep track of how the entire (global) simulation domain is distributed between the MPI processes. For that we have the fortran <code class="language-plaintext highlighter-rouge">type</code> called <code class="language-plaintext highlighter-rouge">mesh</code>. We keep track of all meshblocks in an array of type <code class="language-plaintext highlighter-rouge">mesh</code>:</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">meshblocks</span><span class="p">(</span><span class="n">MPI_size</span><span class="p">)</span><span class="w">
</span><span class="c1">! (i-1)-st rank operates on `meshblocks(i)`, where i goes from `1` to `MPI_size`</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">sx</span><span class="w">  </span><span class="c1">! &lt;- # of cells in x direction for the i-th meshblock</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">sy</span><span class="w">  </span><span class="c1">! &lt;- # of cells in y direction</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">sz</span><span class="w">  </span><span class="c1">! &lt;- # of cells in z direction</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">x0</span><span class="w">  </span><span class="c1">! &lt;- global x-coordinate of the meshblock's corner in the global domain</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">y0</span><span class="w">  </span><span class="c1">! &lt;- global y-coordinate of the meshblock's corner in the global domain</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">z0</span><span class="w">  </span><span class="c1">! &lt;- global z-coordinate of the meshblock's corner in the global domain</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">rnk</span><span class="w"> </span><span class="c1">! &lt;- rank of the MPI process operating on this meshblock</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">neighbor</span><span class="p">(:,:,:)</span><span class="w"> </span><span class="c1">! &lt;- array with pointers to all neighbors of this particular meshblock</span><span class="w">
</span></code></pre></div></div>

<figure><img class="docimage" src="images/tristan_v2/structure/domain2.png" alt="meshblock" /></figure>

<h3 id="meshblock-pointers">Meshblock pointers</h3>
<p>Every local MPI process “knows” about the global structure of the whole simulation domain (which MPI ranks are assigned to which meshblocks etc) through the <code class="language-plaintext highlighter-rouge">meshblocks(:)</code> array. To make life easier we also provide an auxiliary type to <code class="language-plaintext highlighter-rouge">mesh</code>, which is the <code class="language-plaintext highlighter-rouge">meshptr</code> – a pointer to a <code class="language-plaintext highlighter-rouge">mesh</code>-type object. For example, to get the current (local) mesh one can simply do:</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="w">    </span><span class="c1">! &lt;- if we are on rank `i` this will return `meshblocks(i+1)`</span><span class="w">
</span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">sx</span><span class="w"> </span><span class="c1">! &lt;- # of cells in x for current (local) meshblock</span><span class="w">
</span><span class="err">...</span><span class="w">
</span></code></pre></div></div>

<p>With the help of this construct one can also access the neighboring meshblocks and directly address them (e.g., communicate through MPI). The example is shown below.</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">! (i-1)-st MPI rank lives on `meshblocks(i)`</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">neighbor</span><span class="p">(</span><span class="mi">+1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">%</span><span class="n">ptr</span><span class="w"> </span><span class="c1">! &lt;- `mesh`-type object of the direct neighbor in +x direction</span><span class="w">
</span><span class="n">meshblocks</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">neighbor</span><span class="p">(</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="mi">+1</span><span class="p">,</span><span class="mi">-1</span><span class="p">)</span><span class="o">%</span><span class="n">ptr</span><span class="w"> </span><span class="c1">! &lt;- `mesh`-type object of the direct (diagonal) neighbor in +y/-z direction</span><span class="w">
</span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">neighbor</span><span class="p">(</span><span class="mi">+1</span><span class="p">,</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="o">%</span><span class="n">ptr</span><span class="w"> </span><span class="c1">! &lt;- ... you got the point</span><span class="w">
</span></code></pre></div></div>
<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> This <code class="language-plaintext highlighter-rouge">...%ptr</code> is a purely Fortran thing, fortran does NOT allow to have a pointer on an array element of the user-defined type. So we had to make a workaround.</div>

<figure><img class="docimage" src="images/tristan_v2/structure/domain3.png" alt="neighbors" /></figure>

<h3 id="example-of-usage">Example of usage</h3>
<p>If a particle leaves the region our current domain is operating on we will have to send this particle to a new neighboring MPI domain. Let’s say a particle leaves through a upper (+z), left (-x) corner. We can easily verify this by checking the coordinates of our particle (this is just an example):</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">prt_x</span><span class="w"> </span><span class="ow">.lt.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="ow">.and.</span><span class="w"> </span><span class="p">(</span><span class="n">prt_z</span><span class="w"> </span><span class="ow">.ge.</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="c1">! &lt;- this will be `.true.`</span><span class="w">
</span></code></pre></div></div>
<p>This means our current MPI process will need to send this particle to an MPI process with rank:</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">this_mesblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">neighbor</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="mi">+1</span><span class="p">)</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">rnk</span><span class="w">
</span></code></pre></div></div>

<h2 id="fields">Fields</h2>

<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> Relevant file: <code class="language-plaintext highlighter-rouge">src/objects/fields.F90</code>.</div>

<p>There are 9 basic field components: <code class="language-plaintext highlighter-rouge">ex, ey, ez, bx, by, bz, jx, jy, jz</code>. These objects are fairly straightforward: they are just 3 dimensional arrays containing the corresponding components of E-field, B-field and current densities. However there are a few things to keep in mind.</p>

<h3 id="indexing">Indexing</h3>

<p>The numbering of cells in a given MPI domain in each direction goes from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">sx - 1</code> (remember, <code class="language-plaintext highlighter-rouge">sx</code> is our <code class="language-plaintext highlighter-rouge">this_meshblock%ptr%sx</code>). This means that field values in these cells will be stored in, say, <code class="language-plaintext highlighter-rouge">ex(i, j, k)</code> with <code class="language-plaintext highlighter-rouge">i</code> running from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">sx - 1</code>, <code class="language-plaintext highlighter-rouge">j</code> is running from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">sy - 1</code>, etc. Notice, that the real physical coordinates of these cells correspond not to cell centers, but to nodes (see image below).</p>

<figure><img class="docimage" src="images/tristan_v2/structure/fld2.png" alt="indexing" /></figure>

<h3 id="staggering">Staggering</h3>

<p>While real-life electric and magnetic field components are continuous and defined in each and every point in three-dimensional space, the values we store in our arrays are obviously discrete. To make life easier we exploit the so-called staggered, or Yee mesh for storing the electric and magnetic field components (see animation below). This means that a value <code class="language-plaintext highlighter-rouge">ex(i, j, k)</code> is not really a value of the real field in the center of the cell <code class="language-plaintext highlighter-rouge">(i, j, k)</code>, but instead is a value on one of the edges as shown in the image below. So strictly speaking by writing <code class="language-plaintext highlighter-rouge">ex(i, j, k)</code> we really mean $e_x^{i,j-1/2,k-1/2}$. This logic applies to all the field components, including the current density components, which alike the electric field are also stored on the edges of the corresponding cell.</p>

<figure><img class="docimage" src="images/tristan_v2/structure/fld3.gif" alt="yee" /></figure>

<h3 id="ghost-cells">Ghost cells</h3>

<p>During our simulation we might need to compute the field value in a particular spatial position (e.g., at the position of the particle) for which we would interpolate the corresponding component values to a given position. This means that at some point we might need to know a field value stored on a neighboring meshblock. To minimize communications between MPI domains we store some additional fields quantities from the neighboring meshblocks in the so-called ghost zones (denoted by red in the image below). Every timestep we update the values in these ghost cells so they contain the most up-to-date data on the field quantities of neighboring MPI domains.</p>

<p>Conveniently, the indexing of ghost zones (say, in x) goes like:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">NGHOST</code> ghost cells on the left: <code class="language-plaintext highlighter-rouge">i = -NGHOST, ..., -1</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">sx</code> active cells: <code class="language-plaintext highlighter-rouge">i = 0, ..., sx - 1</code>;</li>
  <li><code class="language-plaintext highlighter-rouge">NGHOST</code> ghost cells on the right: <code class="language-plaintext highlighter-rouge">i = sx, ..., sx + NGHOST - 1</code>.</li>
</ul>

<p>Here <code class="language-plaintext highlighter-rouge">NGHOST</code> is a global variable defined on a compilation time which determines how many ghost zones we want to use in our simulation.</p>

<figure><img class="docimage" src="images/tristan_v2/structure/fld1.gif" alt="ghosts" /></figure>

<h3 id="usage-example">Usage example</h3>

<p>Let’s say we want to setup an electromagnetic field propagating in xy direction in a periodic box. Here’s a simple loop that will do the job (example from <code class="language-plaintext highlighter-rouge">user/user_emwave.F90</code>).</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">! `kx` and `ky` are the wavenumbers in global coordinates:</span><span class="w">
</span><span class="n">kx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">ky</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">kx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">global_mesh</span><span class="o">%</span><span class="n">sx</span><span class="w">
</span><span class="n">ky</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ky</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M_PI</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">global_mesh</span><span class="o">%</span><span class="n">sy</span><span class="w">

</span><span class="c1">! normalizing the field components /&gt;</span><span class="w">
</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ky</span><span class="w"> </span><span class="ow">.ne.</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
  </span><span class="n">ex_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ey_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">kx</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">ky</span><span class="p">)</span><span class="w">
</span><span class="k">else</span><span class="w">
  </span><span class="n">ey_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">ex_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">ky</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">kx</span><span class="p">)</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="w">
</span><span class="n">exy_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sqrt</span><span class="p">(</span><span class="n">ex_norm</span><span class="o">**</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ey_norm</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="w">
</span><span class="n">ex_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ex_norm</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">exy_norm</span><span class="w">
</span><span class="n">ey_norm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ey_norm</span><span class="w"> </span><span class="p">/</span><span class="w"> </span><span class="n">exy_norm</span><span class="w">
</span><span class="c1">! &lt;/ normalizing the field components</span><span class="w">

</span><span class="c1">! loop through all the active cells of the current MPI domain</span><span class="w">
</span><span class="k">do</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">sx</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="n">i_glob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">x0</span><span class="w"> </span><span class="c1">! &lt;- converting local to global coordinates</span><span class="w">
  </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">sy</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="n">j_glob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">y0</span><span class="w">
    </span><span class="k">do</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">sz</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="n">k_glob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">z0</span><span class="w">
      </span><span class="c1">! notice that `ex` is staggered in y and z direction ...</span><span class="w">
      </span><span class="n">ex</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ex_norm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">sin</span><span class="p">((</span><span class="n">i_glob</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j_glob</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ky</span><span class="p">)</span><span class="w">
      </span><span class="c1">! ... and `ey` is staggered in x and z direction ...</span><span class="w">
      </span><span class="n">ey</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ey_norm</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">sin</span><span class="p">((</span><span class="n">i_glob</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j_glob</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ky</span><span class="p">)</span><span class="w">
      </span><span class="n">ez</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="n">bx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="n">by</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="c1">! ... and `bz` is staggered in z direction</span><span class="w">
      </span><span class="n">bz</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sin</span><span class="p">((</span><span class="n">i_glob</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">kx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">j_glob</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ky</span><span class="p">)</span><span class="w">
    </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
  </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></code></pre></div></div>

<h2 id="particles">Particles</h2>
<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> Relevant file: <code class="language-plaintext highlighter-rouge">src/objects/particles.F90</code>.</div>

<p>Particles along with fields are the heart and soul of every particle-in-cell code. Particles sample the kinetic distribution function of the multicomponent plasma and also enable to track the dynamics of massless photons.</p>

<h3 id="species">Species</h3>

<p>In this code we support arbitrary number of species that are treated separately. To take care of that we have a special type called <code class="language-plaintext highlighter-rouge">particle_species</code> which has an instance array, <code class="language-plaintext highlighter-rouge">species(:)</code>, containing all the information about particle species.</p>

<h5 id="structure-of-species-type-speciess-where-s--1--nspec">Structure of species type, <code class="language-plaintext highlighter-rouge">species(s)%...</code>, where <code class="language-plaintext highlighter-rouge">s = 1, ..., nspec</code>:</h5>

<table>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">cntr_sp</code></td>
      <td>integer counter to keep track of indexing for the newly created particles</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">m_sp</code>, <code class="language-plaintext highlighter-rouge">ch_sp</code></td>
      <td>mass and charge (normalized to code units) for the species <code class="language-plaintext highlighter-rouge">s</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tile_sx</code>, <code class="language-plaintext highlighter-rouge">tile_sy</code>, <code class="language-plaintext highlighter-rouge">tile_sz</code></td>
      <td>dimensions of particle tiles</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">tile_nx</code>, <code class="language-plaintext highlighter-rouge">tile_ny</code>, <code class="language-plaintext highlighter-rouge">tile_nz</code></td>
      <td>numbers of particle tiles</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">prtl_tile(:,:,:)%...</code></td>
      <td>3d array of particle tiles themselves</td>
    </tr>
  </tbody>
</table>

<h3 id="tiles-and-particles">Tiles and particles</h3>

<p>Tiles are basically smaller chunks of the MPI domain (contained locally within a single MPI process) which store all the information about the particles (see image below).</p>

<p>Their dimension can be configured from the input file, and their number in each direction depends on the local domain size and the size of each individual tile (notice, that some of them might be smaller than <code class="language-plaintext highlighter-rouge">...%tile_sx/sy/sz</code>. Left and right (up/down, front/back) boundaries of the tile are stored on it as well <code class="language-plaintext highlighter-rouge">...%prtl_tile(ti, tj, tk)%x1/x2/y1/y2/...</code>.</p>

<figure><img class="docimage" src="images/tristan_v2/structure/prtl1.png" alt="tiles" /></figure>

<p>Particles in this code are stored as separate arrays within a tile, i.e., their positions and velocities are stored as separate arrays <code class="language-plaintext highlighter-rouge">xi(:), dx(:), u(:), ...</code> (so-called structure of arrays).</p>

<p>To access a particle we first need to access the particular species <code class="language-plaintext highlighter-rouge">s</code>, then address to the particular tile through its three dimensional index <code class="language-plaintext highlighter-rouge">ti, tj, tk</code> and then address to a particle property through its index <code class="language-plaintext highlighter-rouge">p</code> (see image below). E.g., a typical way of addressing would look like the following:</p>
<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">prtl_tile</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span><span class="w"> </span><span class="n">tj</span><span class="p">,</span><span class="w"> </span><span class="n">tk</span><span class="p">)</span><span class="o">%</span><span class="n">xi</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<div class="alert alert-info" role="alert"><i class="fa fa-info-circle"></i> <b>Note:</b> Once a particle leaves the tile, it’s being copied to the new one and removed from the old tile. As these tiles are typically smaller than the entire local MPI domain, it’s fairly easy to reallocate memory and change the number of particles <code class="language-plaintext highlighter-rouge">...%maxptl_sp</code> that a particular tile can carry. This is done in <code class="language-plaintext highlighter-rouge">src/logistics/exchange_particles.F90</code> in <code class="language-plaintext highlighter-rouge">exchangeParticles()</code> subroutine at the same time as the sending between MPI domains is taken care of.</div>

<p>Coordinates of the particle in each direction are stored as two separate arrays. In x they are <code class="language-plaintext highlighter-rouge">xi(:)</code> and <code class="language-plaintext highlighter-rouge">dx(:)</code>, where <code class="language-plaintext highlighter-rouge">xi(p)</code> is the <code class="language-plaintext highlighter-rouge">i</code> index of the cell where particle lives, and <code class="language-plaintext highlighter-rouge">dx(p)</code> is the displacement from the edges of that cell (see image below).</p>

<figure><img class="docimage" src="images/tristan_v2/structure/prtl3.png" alt="coords" /></figure>

<div class="alert alert-success" role="alert"><i class="fa fa-check-square-o"></i> <b>Tip:</b> For massive particles we store three spatial components of their 4-velocity in <code class="language-plaintext highlighter-rouge">u(:)</code>, <code class="language-plaintext highlighter-rouge">v(:)</code>, and <code class="language-plaintext highlighter-rouge">w(:)</code> arrays. So the energy of such a particle (in units of $m c^2$) can be found as <code class="language-plaintext highlighter-rouge">sqrt(1 + u(p)**2 + v(p)**2 + w(p)**2)</code>. In case of massless particles, in the same arrays we store three components of their 4-momentum, meaning that their energy is <code class="language-plaintext highlighter-rouge">sqrt(u(p)**2 + v(p)**2 + w(p)**2)</code>.</div>

<h3 id="usage-example-1">Usage example</h3>

<p>A typical loop over all particles of all species will look like this.</p>

<div class="language-fortran highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">nspec</span><span class="w"> </span><span class="c1">! loop over species</span><span class="w">
  </span><span class="k">do</span><span class="w"> </span><span class="n">ti</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">tile_nx</span><span class="w">      </span><span class="c1">! loop over tiles in x</span><span class="w">
    </span><span class="k">do</span><span class="w"> </span><span class="n">tj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">tile_ny</span><span class="w">    </span><span class="c1">! loop over tiles in y</span><span class="w">
      </span><span class="k">do</span><span class="w"> </span><span class="n">tk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">tile_nz</span><span class="w">  </span><span class="c1">! loop over tiles in z</span><span class="w">
        </span><span class="k">do</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">prtl_tile</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span><span class="w"> </span><span class="n">tj</span><span class="p">,</span><span class="w"> </span><span class="n">tk</span><span class="p">)</span><span class="o">%</span><span class="n">npart_sp</span><span class="w"> </span><span class="c1">! loop over particles in that tile</span><span class="w">
          </span><span class="c1">! getting global `x` coordinate of the particle `p` (notice adding `x0`)</span><span class="w">
          </span><span class="n">x_glob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">REAL</span><span class="p">(</span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">prtl_tile</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span><span class="w"> </span><span class="n">tj</span><span class="p">,</span><span class="w"> </span><span class="n">tk</span><span class="p">)</span><span class="o">%</span><span class="n">xi</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this_meshblock</span><span class="o">%</span><span class="n">ptr</span><span class="o">%</span><span class="n">x0</span><span class="p">)&amp;</span><span class="w">
                 </span><span class="p">&amp;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">species</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">%</span><span class="n">prtl_tile</span><span class="p">(</span><span class="n">ti</span><span class="p">,</span><span class="w"> </span><span class="n">tj</span><span class="p">,</span><span class="w"> </span><span class="n">tk</span><span class="p">)</span><span class="o">%</span><span class="n">dx</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w">
          </span><span class="err">...</span><span class="w">
        </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
      </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
    </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
  </span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">do</span><span class="w">
</span></code></pre></div></div>


    <div class="tags">
        
    </div>




</div>

<hr class="shaded"/>

<footer>
<div class="row">
  <div class="col-lg-12 footer">
    &copy;2020 Plasmoids. All rights reserved. <br />
<span>Page last updated:</span> Dec 17, 2019<br/> Site last generated: Jan 3, 2020 <br />
  </div>
</div>
</footer>


        </div>
    <!-- /.row -->
</div>
<!-- /.container -->
</div>
<!-- /#main -->
    </div>
</body>
</html>
